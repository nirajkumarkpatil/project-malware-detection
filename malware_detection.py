# -*- coding: utf-8 -*-
"""malware detection1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pmiLN_15koI8twI6gUcuZOFxoNyn_-4A
"""

from sklearn.naive_bayes import GaussianNB, BernoulliNB
from sklearn.metrics import accuracy_score, classification_report
from sklearn.ensemble import BaggingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import SGDClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import cohen_kappa_score
from sklearn.metrics import confusion_matrix
from sklearn.ensemble import RandomForestClassifier

from sklearn import preprocessing
from sklearn import svm
from sklearn import tree
import pandas as pd
#from sklearn.externals import joblib
import pickle
import numpy as np

from sklearn.metrics import f1_score
from sklearn.metrics import precision_score
from sklearn.metrics import recall_score
from sklearn.metrics import average_precision_score
from sklearn.metrics import precision_recall_curve
import matplotlib.pyplot as plt

from sklearn.pipeline import make_pipeline
from sklearn.model_selection import cross_val_score

#from tensorflow.keras.models import Sequential
#from tensorflow.keras.layers import Dense, Flatten, Conv2D, MaxPooling2D,Dropout
#from tensorflow.keras.losses import sparse_categorical_crossentropy
#from tensorflow.keras.optimizers import Adam
from sklearn.impute import SimpleImputer
from sklearn.model_selection import KFold
from sklearn.svm import SVR
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import confusion_matrix,accuracy_score,precision_score,f1_score
from collections import Counter
from sklearn.metrics import brier_score_loss
from sklearn.metrics import roc_auc_score

from sklearn.feature_selection import SelectKBest 
from sklearn.feature_selection import chi2
import numpy as np




def getPredictedMalware(dwnload,ext_storage,access_ntw):
    print(dwnload,ext_storage,access_ntw)
    df=pd.read_excel('train.xlsx',sep=";",delim_whitespace=True)

    #df = df.astype("int64")
    df.type.value_counts()

    df.shape

    df

    pd.Series.sort_values(df[df['type']==1].sum(axis=0), ascending=False)[1:11]

    pd.Series.sort_values(df[df['type']==0].sum(axis=0), ascending=False)[:10]

    import matplotlib.pyplot as plt
    fig, axs =  plt.subplots(nrows=2, sharex=True)

    pd.Series.sort_values(df[df.type==0].sum(axis=0), ascending=False)[:10].plot.bar(ax=axs[0])
    pd.Series.sort_values(df[df.type==1].sum(axis=0), ascending=False)[1:11].plot.bar(ax=axs[1], color="red")

    X_train, X_test, y_train, y_test = train_test_split(df.iloc[:, 1:330], df['type'], test_size=0.20, random_state=42)

    df['type']

    #Cross validation
    X_train=df.iloc[:, 0:329]
    y_train=df['type']
    gnb = GaussianNB()

    # Naive Bayes algorithm
    gnb = GaussianNB()
    gnb.fit(X_train, y_train)

    # pred
    pred = gnb.predict(X_test)

    # accuracy
    accuracy = accuracy_score(pred, y_test)
    print("naive_bayes")
    print(classification_report(pred, y_test, labels=None))



    #get scoreset 
    s=scoreset(y_test,pred)

    # kneighbors algorithm

    for i in range(3,15,3):
        
        neigh = KNeighborsClassifier(n_neighbors=i)
        neigh.fit(X_train, y_train)
        pred = neigh.predict(X_test)
        # accuracy
        accuracy = accuracy_score(pred, y_test)
        print("kneighbors {}".format(i))
        print(accuracy)
        print(classification_report(pred, y_test, labels=None))
        s=scoreset(y_test,pred)

    clf = tree.DecisionTreeClassifier()
    clf.fit(X_train, y_train)

    # Read the csv test file

    pred = clf.predict(X_test)
    # accuracy
    accuracy = accuracy_score(pred, y_test)
    print(clf)
    print(accuracy)
    print(classification_report(pred, y_test, labels=None))
    s=scoreset(y_test,pred)

    #LinearSVM
    from sklearn import svm

    lin_clf = svm.LinearSVC()
    lin_clf.fit(X_train, y_train)
    pred = lin_clf.predict(X_test)
    # accuracy
    accuracy = accuracy_score(pred, y_test)
    print(accuracy)
    print(classification_report(pred, y_test, labels=None))
    s=scoreset(y_test,pred)

    import pickle
    pickle_out = open("classifier.pkl","wb")
    pickle.dump(lin_clf,pickle_out)
    pickle_out.close()

    import numpy as np
    #a=lin_clf.predict([[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])
    
    output1=lin_clf.predict([[0,0,0,0,dwnload,ext_storage,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,access_ntw,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]])
    output2=lin_clf.predict([[1,1,1,1,dwnload,ext_storage,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,access_ntw, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  0,  0,  0, 1, 1,  0, 1,  0, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])
    output_value=0
    if(output1 is not None and len(output1)>0):
        output_value1=output1[0]
        output_value2=output2[0]
    output_json1={'Dataset_1':{'malware_detected':int(output_value1)},
                  'Dataset_2': {'malware_detected':int(output_value2)}}
                   
    return output_json1

def custom_cross_validation1(model, X_train, y_train, cv):
    my_pipeline = make_pipeline(SimpleImputer(), model)
    scores = cross_val_score(my_pipeline, X_train, y_train, cv=cv)
    print("%0.2f accuracy with a standard deviation of %0.2f" % (scores.mean(), scores.std()))
    return scores

    #sc=custom_cross_validation(gnb, X_train, y_train, cv=10)

    #R square
def r2(y_true,y_pred):
    import numpy as np
    m_t_v=np.mean(y_true)
    numerator=0
    denominator=0
    for yt,yp in zip(y_true,y_pred):
        numerator +=(yt-yp)**2
        denominator +=(yt-m_t_v)**2
    r=numerator/denominator
    return 1-r

def mcc(y_true,y_pred):
    tn, fp, fn, tp = confusion_matrix(y_true,y_pred).ravel()
    n=(tp*tn)-(fp*fn)
    d=((tp+fp)*(fn+tn)*(fp+tn)*(tp+fn))
    d=d**0.5
    r=n/d
    return r

def scoreset(y_true,y_pred):
    score_set=[]
    pred=y_pred
    y_test=y_true
    print("cohen kappa score",cohen_kappa_score(y_test, pred))
    score_set.append(cohen_kappa_score(y_test, pred))
    print("cohen kappa score quadratic",cohen_kappa_score(y_test, pred, weights="quadratic"))
    score_set.append(cohen_kappa_score(y_test, pred, weights="quadratic"))
    print("R square score", r2(y_test,pred))
    score_set.append(r2(y_test,pred))
    print("MCC score", mcc(y_test,pred))
    score_set.append(mcc(y_test,pred))
    print("Brier Score Loss",brier_score_loss(y_test, pred))
    score_set.append(brier_score_loss(y_test, pred))
    print("AUC ROC Score",roc_auc_score(y_test, pred))
    score_set.append(roc_auc_score(y_test, pred))
    print("")
    print("accuracy:",accuracy_score(y_test,pred))
    score_set.append(accuracy_score(y_test,pred))
    print("F1 Score:",f1_score(y_test,pred))
    score_set.append(f1_score(y_test,pred))
    print("Precision:",precision_score(y_test,pred))
    score_set.append(precision_score(y_test,pred))
    print("Recall:",recall_score(y_test,pred))
    score_set.append(recall_score(y_test,pred))
    return score_set

    

def retrieveMalware_all():
    return getPredictedMalware(0,0,0)

def retrieveMalware(dwnload,ext_storage,access_ntw):
    return getPredictedMalware(dwnload,ext_storage,access_ntw)







